<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Tengchuan</title>
 <link href="http://wangtengchuan.github.io/atom.xml" rel="self"/>
 <link href="http://wangtengchuan.github.io"/>
 <updated>2016-09-09T17:28:58+08:00</updated>
 <id>http://wangtengchuan.github.io</id>
 <author>
   <name>Tengchuan Wang</name>
   <email>wangtengchuan@gmail.com</email>
 </author>

 
 <entry>
   <title>Introduction to MongoDB</title>
   <link href="http://wangtengchuan.github.io/database/2016/09/05/IntroductionToMongoDB"/>
   <updated>2016-09-05T00:00:00+08:00</updated>
   <id>http://wangtengchuan.github.io/database/2016/09/05/IntroductionToMongoDB</id>
   <content type="html">
&lt;h1 id=&quot;introduction-to-mongodb&quot;&gt;Introduction to MongoDB&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://webassets.mongodb.com/_com_assets/global/mongodb-logo-white.png&quot; alt=&quot;mongoDB logo&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mongobd&quot;&gt;什么是MongoBD&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MongoDB&lt;/strong&gt;是一个基于分布式文件存储的数据库。由C++编写。一般来讲，我们可以选择的数据库有Mysql, MongoDB, Redis.他们的区别是什么？适用场景是什么？本文主要通过讲解MongoDB的基本用法、特性对MongoDB特性、适用场景有基本理解。&lt;/p&gt;

&lt;h2 id=&quot;mongodb&quot;&gt;为什么选择MongoDB&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MongoDB&lt;/strong&gt;是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。MongoDB最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。
适用场景：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网站数据：MongoDB非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。&lt;/li&gt;
  &lt;li&gt;缓存：由于性能很高，Mongo 也适合作为信息基础设施的缓存层。在系统重启之后，由Mongo 搭建的持久化缓存层可以避免下层的数据源过载。&lt;/li&gt;
  &lt;li&gt;大尺寸、低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。&lt;/li&gt;
  &lt;li&gt;高伸缩性的场景：MongoDB 非常适合由数十或数百台服务器组成的数据库，Mongo 的路线图中已经包含对MapReduce引擎的内置支持。&lt;/li&gt;
  &lt;li&gt;用于对象及JSON数据的存储：MongoDB的BSON数据格式非常适合文档化格式的存储及查询。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;个人使用下来的感受：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当系统内存可用空间充足的时候，mongoDB会将文档加载到内存中(可以配置)。所以检索速度相当快，比单纯的Mysql快一个数量级；&lt;/li&gt;
  &lt;li&gt;强大的查询功能，支持Aggregation以及Map-reduce;&lt;/li&gt;
  &lt;li&gt;灵活的schema(对数据没有非常强的规整性约束)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;基本概念&lt;/h2&gt;

&lt;h3 id=&quot;bson&quot;&gt;BSON&lt;/h3&gt;
&lt;p&gt;通俗一点理解，BSON是一种二进制化的json数据。不过不同点在于BSON是有强类型约束的，而json是弱类型。强类型的可序列化数据可以用作RPC, 这点上一般把BSON跟protobuf比较。&lt;/p&gt;

&lt;p&gt;####BSON数据类型&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Type&lt;/th&gt;
      &lt;th&gt;Number&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Double&lt;/td&gt;
      &lt;td&gt;“double”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;“string”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Object&lt;/td&gt;
      &lt;td&gt;“object”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Array&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;“array”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Binary data&lt;/td&gt;
      &lt;td&gt;“binData”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ObjectId&lt;/td&gt;
      &lt;td&gt;“objectId”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;“bool”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Date&lt;/td&gt;
      &lt;td&gt;“date”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Null&lt;/td&gt;
      &lt;td&gt;“null”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Regular Expression&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;“regex”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DBPointer&lt;/td&gt;
      &lt;td&gt;“dbPointer”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;JavaScript&lt;/td&gt;
      &lt;td&gt;“javascript”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Symbol&lt;/td&gt;
      &lt;td&gt;“symbol”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;JavaScript (with scope)&lt;/td&gt;
      &lt;td&gt;“javascriptWithScope”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;32-bit integer&lt;/td&gt;
      &lt;td&gt;“int”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Timestamp&lt;/td&gt;
      &lt;td&gt;“timestamp”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;64-bit integer&lt;/td&gt;
      &lt;td&gt;“long”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Min key&lt;/td&gt;
      &lt;td&gt;“minKey”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Max key&lt;/td&gt;
      &lt;td&gt;“maxKey”&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-1&quot;&gt;数据模型&lt;/h3&gt;
&lt;p&gt;databases(可以理解成Mysql的一个数据库)
	|
collection(一个database可以有多个colletion,类比table)
	|
document(一行数据对应一个document，只不过相对于Mysql的一行，document结构比较松散)
{“hello,word”:“Mike”}&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;基本操作&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;db.colletion.insert(
	{
		name: &quot;sue&quot;,
		age: 26,
		status: &quot;A&quot;
	}
)

db.user.find(
	{age: {$gt: 18}},
	{name: 1}
).limit(5)

db.user.update(
	{age:{$gt:18}},
	{$set: {status: &quot;A&quot;}}
)

db.user.remove(
	{status: &quot;D&quot;}
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  _id: ObjectId(&quot;509a8fb2f3f4948bd2f983a0&quot;),
  user_id: &quot;abc123&quot;,
  age: 55,
  status: &#39;A&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么与Mysql的区别在哪里呢？MongoDB在插入前不需要定义一个表的schema，也就是说文档类型是灵活的。&lt;/p&gt;

&lt;h4 id=&quot;bulk-write&quot;&gt;Bulk Write&lt;/h4&gt;
&lt;p&gt;批量插入，可以减少io次数。同时MongoDB可以指定Bulk Write是有序还是无序的。
不过不同于Mysql的Transaction, MongoDB不能保证Bulk Write的原子性，也就是不能如果多条指令的一条出错，那么这条指令之前的都会被执行，这条之后的不会被执行，不支持回滚。如果你熟悉Redis的话，你也会知道Redis的Transaction也是不能回滚的。&lt;/p&gt;

&lt;p&gt;MongoDB Bulk Write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.characters.bulkWrite(
      [
         { insertOne :
            {
               &quot;document&quot; :
               {
                  &quot;_id&quot; : 4, &quot;char&quot; : &quot;Dithras&quot;, &quot;class&quot; : &quot;barbarian&quot;, &quot;lvl&quot; : 4
               }
            }
         },
         { insertOne :
            {
               &quot;document&quot; :
               {
                  &quot;_id&quot; : 5, &quot;char&quot; : &quot;Taeln&quot;, &quot;class&quot; : &quot;fighter&quot;, &quot;lvl&quot; : 3
               }
            }
         },
         { updateOne :
            {
               &quot;filter&quot; : { &quot;char&quot; : &quot;Eldon&quot; },
               &quot;update&quot; : { $set : { &quot;status&quot; : &quot;Critical Injury&quot; } }
            }
         },
         { deleteOne :
            { &quot;filter&quot; : { &quot;char&quot; : &quot;Brisbane&quot;} }
         },
         { replaceOne :
            {
               &quot;filter&quot; : { &quot;char&quot; : &quot;Meldane&quot; },
               &quot;replacement&quot; : { &quot;char&quot; : &quot;Tanys&quot;, &quot;class&quot; : &quot;oracle&quot;, &quot;lvl&quot; : 4 }
            }
         }
      ]
   );

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Redis Transaction&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; MULTI
OK
&amp;gt; INCR foo
QUEUED
&amp;gt; INCR bar
QUEUED
&amp;gt; EXEC
1) (integer) 1
2) (integer) 1

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么他们与什么区别，我个人理解，Redis的Transaction更像是Mysql的stored procedures.它能保证一系列指令按照顺序执行，但是不能保证原子性。MongoDB同样不能保证原子性，它的执行顺序是可以手动指定的。&lt;/p&gt;

&lt;h4 id=&quot;pipeline&quot;&gt;pipeline&lt;/h4&gt;
&lt;p&gt;MongoDB的pipeline跟Linux Shell的pipeline相似，上一个的输出作为下一个的输入。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.collection.aggregate([{$match:{status:&quot;A&quot;}},
							{$group:{_id:&quot;$cust_id&quot;, 
							total: {$sum: &quot;$amount&quot;}}}
]
)

db.orders.mapReduce(
			function() {emit(this.cust_id, this.amount);},
			function() {key, values} (return Array.sum(values)},
			{
				query:{$or: [{status: &quot;A&quot;}, {age:{$lt: 30}}},
				out: &quot;order_totals&quot;
			}
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;query-&amp;gt;map-&amp;gt;reduce&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;Reference&lt;/h4&gt;
&lt;p&gt;类似于Mysql的外键，可以用来减少表中的冗余信息。
&lt;img src=&quot;https://docs.mongodb.com/manual/_images/data-model-normalized.png&quot; alt=&quot;reference&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;advanced&quot;&gt;Advanced&lt;/h2&gt;

&lt;h3 id=&quot;index&quot;&gt;Index&lt;/h3&gt;
&lt;p&gt;MongoDB提供了非常完整而强大的索引功能。默认情况下，对_id字段进行索引(所以_id不能重复)。我们自己也可以为某个字段增加index:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;_id&quot;: ObjectId(&quot;570c04a4ad233577f97dc459&quot;),
  &quot;score&quot;: 1034,
  &quot;location&quot;: { state: &quot;NY&quot;, city: &quot;New York&quot; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面以升序的方式建立索引(-1是降序)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.records.createIndex( { score: 1 } )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么我们在find时候就会用到这个index&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.records.find( { score: 2 } )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;####嵌套的Index&lt;/p&gt;

&lt;p&gt;对于嵌套的field,我们既可以对整个嵌套域建立索引，也可以对嵌套域内的某个field建立索引。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;_id&quot;: ObjectId(&quot;570c04a4ad233577f97dc459&quot;),
  &quot;score&quot;: 1034,
  &quot;location&quot;: { state: &quot;NY&quot;, city: &quot;New York&quot; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么可以对location本身建立索引:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.records.createIndex( { location: 1 } )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以对location中的state字段建立索引。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.records.createIndex( { &quot;location.state&quot;: 1 } )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####联合索引&lt;/p&gt;

&lt;p&gt;MongoDB可以建立不超过31个索引项的联合索引。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
 &quot;_id&quot;: ObjectId(...),
 &quot;item&quot;: &quot;Banana&quot;,
 &quot;category&quot;: [&quot;food&quot;, &quot;produce&quot;, &quot;grocery&quot;],
 &quot;location&quot;: &quot;4th Street Store&quot;,
 &quot;stock&quot;: 4,
 &quot;type&quot;: &quot;cases&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;db.products.createIndex( { &quot;item&quot;: 1, &quot;stock&quot;: 1 } )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个联合索引对于下面两种查询都支持：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.products.find( { item: &quot;Banana&quot; } )
db.products.find( { item: &quot;Banana&quot;, stock: { gt: 5 } } )
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;storage-engine&quot;&gt;Storage Engine&lt;/h3&gt;
&lt;p&gt;strorage engine决定了数据在（内存和磁盘中的）存储和管理方式。MongoDB主要有三种strorage engine(具体用哪种可以在启动mongo-server的时候配置，如果不配置的话就用默认的):&lt;/p&gt;

&lt;h4 id=&quot;wiredtiger&quot;&gt;WiredTiger&lt;/h4&gt;
&lt;p&gt;MongoDB 3.2开始支持的默认的存储引擎，也是官方推荐的存储引擎。主要功能:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;document-level concurrency
多个客户度可以同时写一个collection的不同的行，与mysql InnoDB行级锁是一样的。&lt;/li&gt;
  &lt;li&gt;checkpoingting &amp;amp; journal
checkpoint主要是在插入数据的时候做快照，journal主要是记录所有的数据修改。&lt;/li&gt;
  &lt;li&gt;compressing
MongoDB可以利用空闲的CPU对数据和索引进行压缩。默认使用zlib压缩算法&lt;/li&gt;
  &lt;li&gt;encryption&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mmapv1&quot;&gt;MMAPv1&lt;/h4&gt;
&lt;p&gt;MongoDB3.2之前的默认，这里略过。&lt;/p&gt;

&lt;h4 id=&quot;in-memory-storage-engine&quot;&gt;In-Memory Storage Engine&lt;/h4&gt;

&lt;h3 id=&quot;replication&quot;&gt;Replication(复制)&lt;/h3&gt;
&lt;p&gt;与Mysql, Redis一样，MongoDB支持复制。&lt;strong&gt;复制集&lt;/strong&gt;提供了冗余、读写分离、容错、failover以及其他一些高性能。&lt;/p&gt;

&lt;p&gt;####Mysql replication&lt;/p&gt;

&lt;p&gt;Mysql replication的一般的适用场景是大量读，少量写的情况。对于有频繁写的业务，由于Mysql replication的同步是异步，带来的延迟可能导致脏数据。实际上在5.5版本之前，Mysql是不能保证主从同步的实时性的。所以对于实时要求比较高的业务，Mysql读写分离不是一个好的选择。当然Mysql最新的版本支持semi-sync replication，&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;基本原则&lt;/h4&gt;
&lt;p&gt;一个&lt;strong&gt;复制集&lt;/strong&gt;只能有一个主数据库，只有主数据库节点可以接受写的请求。与Mysql一样，主节点纪录所有的修改到一个log文件中（在Mysql中是binLog）。&lt;/p&gt;

&lt;h4 id=&quot;hearbeat&quot;&gt;hearbeat(心跳检测)&lt;/h4&gt;
&lt;p&gt;如果primary在10s之内没有与其他数据库通讯，就认为primary挂掉了。那么剩下的数据库就会通过一个投票算法选出新的primary，整个过程是自动进行的，无需人工干预。&lt;/p&gt;

&lt;p&gt;##一点结论&lt;/p&gt;

&lt;p&gt;MongoDB是一个基于文档的数据库，MongoDB善长的是对无模式JSON数据的查询。由于可以放在内存中，查询效率比Mysql高。
而Redis是一个基于内存的Key-Value数据库，先读写内存再异步同步到磁盘，读写速度上比MongoDB有巨大的提升。但是不支持复杂查询。&lt;/p&gt;

&lt;p&gt;测试：500W条嵌套式(embedded document)数据，根据子内容条件查询获取父内容的操作只需要一次I/O，平均耗时1ms（未进行cluster，条件字段有索引，整个Collection体积将近10G）。&lt;/p&gt;

&lt;p&gt;上述操作对于Memcached＋Mysql组合通常需要2-3次I/O（区别于具体设计），即：通过子内容条件查询到子内容主键，然后从Memcached中缓存的entity获取关联的父内容主键，然后从Memcached中获取父内容。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Python装饰器</title>
   <link href="http://wangtengchuan.github.io/python/2016/09/04/python-decorator"/>
   <updated>2016-09-04T00:00:00+08:00</updated>
   <id>http://wangtengchuan.github.io/python/2016/09/04/python-decorator</id>
   <content type="html">
&lt;p&gt;#Python装饰器&lt;/p&gt;

&lt;p&gt;###装饰器基础&lt;/p&gt;

&lt;p&gt;####Python函数也是对象
在python中&lt;strong&gt;函数即对象&lt;/strong&gt;，这是理解装饰器的基础。首先我们来看一个简单的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
	def shout(word=&quot;yes&quot;):
	    return word.capitalize()+&quot;!&quot;
	    
	print shout()
	$ outputs : &#39;Yes!&#39;

	#既然函数是对象，那么我们也可以像操作其他对象一样，当然也可以把函数赋值给其他对象。
	scream = shout
	#注意到我们在这里没有用shout(),也就是没有加括号，
	#不加括号意味着我们在这里并不是要调用这个函数，
	#也就是说我们把函数&quot;shout&quot;赋值给了变量&quot;scream&quot;。
	#所以可以用scream来调用shout。
	print scream()
	$ outputs : &#39;Yes!&#39;
	#同时，这也意味着你可以删除原先的函数名&quot;shout&quot;,但是我们依然可以通过
	#&quot;scream&quot;来调用函数
	del shout
	try:
	    print shout()
	except NameError, e:
	    print e
	$outputs: &quot;name &#39;shout&#39; is not defined&quot;
	
	print scream()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，在Python中，我们可以在一个函数内定义另外一个函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;	def talk():
	
	    # 在函数talk里面定义函数&quot;whisper&quot; ...
	    def whisper(word=&quot;yes&quot;):
	        return word.lower()+&quot;...&quot;
	
	    # 并且可以立即使用函数whisper
	
	    print whisper()
	
	# 每次调用&quot;talk&quot;时, 就会定义并且调用&quot;whisper&quot;	talk()
	# outputs: 
	# &quot;yes...&quot;
	
	# 需要注意的是&quot;whisper&quot;的作用域仅仅存在&quot;talk&quot;函数内部:
	
	try:
	    print whisper()
	except NameError, e:
	    print e
	    #outputs : &quot;name &#39;whisper&#39; is not defined&quot;*
	    #Python&#39;s functions are objects
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####函数引用
通过上面讲解，我们知道了两点：
1. 函数可以赋给一个变量；
2. 可以在函数内部定义函数。
这也就意味着可以在函数内部返回另外一个函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;	def getTalk(kind=&quot;shout&quot;):
	
		#定义两个函数
	    def shout(word=&quot;yes&quot;):
	        return word.capitalize()+&quot;!&quot;
	
	    def whisper(word=&quot;yes&quot;) :
	        return word.lower()+&quot;...&quot;;
	
	    #返回函数
	    if kind == &quot;shout&quot;:
	        # We don&#39;t use &quot;()&quot;, we are not calling the function,
	        # we are returning the function object
	        return shout  
	    else:
	        return whisper
	
	
	#将函数赋值给一个变量
	talk = getTalk()      
	
	# 因此这里的&quot;talk&quot;是一个函数对象:
	print talk
	#outputs : &amp;lt;function shout at 0xb7ea817c&amp;gt;
	
	# 加上()我们就可以调用这个函数:
	print talk()
	#outputs : Yes!

	print getTalk(&quot;whisper&quot;)()
	#outputs : yes...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然我们可以将函数作为结果返回，那么也可以将函数作为参数传递进一个函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;	def do_something_before(func):
		print &quot;I do something before then I call the function you gave me&quot;
		print func()
	do_something_before(scream)
	#outputs: 
	#I do something before then I call the function you gave me
	#Yes!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到这里，我们终于可以揭开装饰器的真面目了，装饰器就是”wrappers”，也就是说它可以让你在不改变函数实现的情况下改变函数的功能（通过在函数执行前后执行一些代码）。&lt;/p&gt;

&lt;p&gt;####手动实现装饰器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;	def my_shiny_new_decorator(a_function_to_decorate):
		def the_wrapper_around_original_function():
			print &quot;before the function runs&quot;
			a_function_to_decorate()#调用原函数
			print &quot;After the function runs&quot;
			
		return the_wrapper_around_original_function
		
	#接下来我们来使用这个装饰器
	def a_stand_alone_function():
		print &quot;I am a stand alone function, don&#39;t you dare modify me&quot;
	#用装饰器包装这个函数
	my_shiny_new_decorator(a_stand_alone_function)
	#为了不改变函数名，可以overwrite原函数
	a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###解密装饰器
我们经常看到的代码是这样子的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;	@my_shiny_new_decorator
	def another_stand_alone_function():
	    print &quot;Leave me alone&quot;
	
	another_stand_alone_function()  
	#outputs:  
	#Before the function runs
	#Leave me alone
	#After the function runs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的&lt;strong&gt;@decorator&lt;/strong&gt;就等同于
&lt;code&gt;
	another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当然，你也可以嵌套装饰器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;	def bread(func):
	    def wrapper():
	        print &quot;&amp;lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&amp;gt;&quot;
	        func()
	        print &quot;&amp;lt;\______/&amp;gt;&quot;
	    return wrapper
	
	def ingredients(func):
	    def wrapper():
	        print &quot;#tomatoes#&quot;
	        func()
	        print &quot;~salad~&quot;
	    return wrapper
	
	def sandwich(food=&quot;--ham--&quot;):
	    print food
	
	sandwich()
	#outputs: --ham--
	sandwich = bread(ingredients(sandwich))
	sandwich()
	#outputs:
	#&amp;lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&amp;gt;
	# #tomatoes#
	# --ham--
	# ~salad~
	#&amp;lt;\______/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用python的语法格式如下:&lt;strong&gt;注意顺序&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;	@bread
	@ingredients
	def sandwich(food=&quot;--ham--&quot;):
	    print food
	
	sandwich()
	#outputs:
	#&amp;lt;/&#39;&#39;&#39;&#39;&#39;&#39;\&amp;gt;
	# #tomatoes#
	# --ham--
	# ~salad~
	#&amp;lt;\______/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###向装饰器函数传递参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;	def a_decorator_passing_arguments(function_to_decorate):
		def a_wrapper_accepting_arguments(arg1, arg2):
			print &quot;I got args! Look:&quot;, arg1, arg2
			function_todecorate(arg1, arg2)
		return a_wrapper_accepting_arguments
		
	@ a_decorator_passing_arguments
	def print_full_name(first_name, last_name):
		print &quot;My full name is: &quot;, first_name, last_name
		
	print_full_name(&quot;Tengchuan&quot;, &quot;Wang&quot;)
	# outputs:
	#I got args! Look: Tengchuan Wang
	#My name is Tengchuan Wang
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要设计一个通用的装饰器函数，也就是说这个装饰器接受任意的函数以及任意参数，那么应该使用 &lt;em&gt;args, **kwargs:
(关于&lt;/em&gt;args, &lt;em&gt;*kwargs的解释，参见[这里]
(http://stackoverflow.com/questions/3394835/args-and-kwargs)
```python
	def a_decorator_passing_arbitrary_arguments(function_to_decorate):
		def a_wrapper_accepting_arbitrary_arguments(&lt;/em&gt;args, &lt;em&gt;*kwargs):
			print “Do I have args?:”
	       print args
	       print kwargs
	       function_to_decorate(&lt;/em&gt;args, **kwargs)
	   return a_wrapper_accepting_arbitrary_arguments&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@a_decorator_passing_arbitrary_arguments
def function_with_no_argument():
	print &quot;Python is cool, no argument here.&quot;

function_with_no_argument()
#outputs
#Do I have args?:
#()
#{}
#Python is cool, no argument here.

@a_decorator_passing_arbitrary_arguments
def function_with_arguments(a, b, c):
	print a, b, c
	
function_with_arguments(1,2,3)
#outputs
#Do I have args?:
#(1, 2, 3)
#{}
#1 2 3 

@a_decorator_passing_arbitrary_arguments
def function_with_named_arguments(a, b, c, playus = &quot;Why not ?&quot;):
	print &quot;Do %s, %s and %s like platypus? %s&quot; %\
	(a, b, c, platypus)
	
function_with_named_arguments(&quot;Bill&quot;, &quot;Linus&quot;, &quot;Steve&quot;, platypus=&quot;Indeed!&quot;)
#outputs
#Do I have args ? :
#(&#39;Bill&#39;, &#39;Linus&#39;, &#39;Steve&#39;)
#{&#39;platypus&#39;: &#39;Indeed!&#39;}
#Do Bill, Linus and Steve like platypus? Indeed!

#对于类函数的装饰器使用，只需要注意类函数的第一个参数是self即可
class Mary(object):
	def __init__(self):
		self.age = 31
		
	@a_decorator_passing_arbitrary_arguments
	def say_your_age(self, lie = -3):
		print &quot;Iam %s, what did you think ?&quot; % (self.age + lie)

m = Mary()
m. say_your_age()
#outputs
# Do I have args?:
#(&amp;lt;__main__.Mary object at 0xb7d303ac&amp;gt;,)
#{}
#I am 28, what did you think? ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们再深入一步，看一看装饰器究竟是怎么工作的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;	def my_decorator(func):
	    print &quot;I am an ordinary function&quot;
	    def wrapper():
	        print &quot;I am function returned by the decorator&quot;
	        func()
	    return wrapper
	
	# Therefore, you can call it without any &quot;@&quot;
	
	def lazy_function():
	    print &quot;zzzzzzzz&quot;
	
	decorated_function = my_decorator(lazy_function)
	#outputs: I am an ordinary function
	
	# It outputs &quot;I am an ordinary function&quot;, because that’s just what you do:
	# calling a function. Nothing magic.
	
	@my_decorator
	def lazy_function():
	    print &quot;zzzzzzzz&quot;
	
	#outputs: I am an ordinary function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以我们知道了，用@my_deco就是调用了装饰器函数my_deco
&lt;a href=&quot;http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python&quot;&gt;http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>vim技巧</title>
   <link href="http://wangtengchuan.github.io/2016/03/19/vim"/>
   <updated>2016-03-19T00:00:00+08:00</updated>
   <id>http://wangtengchuan.github.io/2016/03/19/vim</id>
   <content type="html">
&lt;p&gt;#VIM技巧
&lt;strong&gt;VIM&lt;/strong&gt;是非常好用的在粘贴剪贴板的多行文本的时候，文本会[自动缩进][1]。非常头疼。其实有一个比较好的解决方案，就是设置进入粘贴模式&lt;em&gt;set paste&lt;/em&gt;。然后粘贴完毕的时候又取消粘贴模式&lt;em&gt;set nopaste&lt;/em&gt;。可以在配置文件里面设置F9键为切换键。*set pastetoggle=&lt;f9&gt;*
[1]http://hi.csdn.net/attachment/201103/1/0_12989517383EM3.gif&lt;/f9&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Redis</title>
   <link href="http://wangtengchuan.github.io/2016/03/19/redis"/>
   <updated>2016-03-19T00:00:00+08:00</updated>
   <id>http://wangtengchuan.github.io/2016/03/19/redis</id>
   <content type="html">&lt;h1 id=&quot;redis&quot;&gt;Redis初探&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://redis.io/images/redis-white.png&quot; alt=&quot;redis icon&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt;, 是一个开源的内存数据存储，采用ANSI C编写。可以用作内存数据库、缓存以及消息队列。作为一个key/value存储系统，它的特点主要集中在这几个方面：
1. 它支持非常丰富的数据类型：&lt;em&gt;string&lt;/em&gt;, &lt;em&gt;hashes&lt;/em&gt;, &lt;em&gt;list&lt;/em&gt;, &lt;em&gt;set&lt;/em&gt;, &lt;em&gt;sorted set&lt;/em&gt;, &lt;em&gt;bitmap&lt;/em&gt;, &lt;em&gt;hyperloglogs&lt;/em&gt;, &lt;em&gt;geospatial indexes&lt;/em&gt;。而且这些数据类型的操作大部分是原子性的。
2. 支持[主从复制][1], &lt;a href=&quot;http://resizesafari.com/favicon.ico&quot; title=&quot;Title&quot;&gt;&lt;em&gt;Lua scripting&lt;/em&gt;&lt;/a&gt;, [&lt;em&gt;LRU cache&lt;/em&gt;][3],
3. 支持[事物][]，&lt;em&gt;redis&lt;/em&gt;提供了事物的功能，MULTI, EXEC, DISCARD 和 WATCH 命令是Redis事务的基石。一个Redis事务允许一组Redis命令单步执行，并提供下面两个重要保证：一个事务中的所有命令串行执行；要么全部命令要么没有任何命令被处理。也就是说redis事物可以保证一串指令操作的原子性，但是不同于&lt;em&gt;mysql&lt;/em&gt;，redis并没有使用lock来实现事物，所以效率比较高。
[1]:http://redis.io/topics/replication
&lt;a href=&quot;http://resizesafari.com/favicon.ico&quot; title=&quot;Title&quot;&gt;2&lt;/a&gt;http://redis.io/commands/eval
[3]http://redis.io/topics/lru-cache
[4]:http://dev.mysql.com/doc/refman/5.7/en/replication-solutions-scaleout.html
### Syntax&lt;/p&gt;

&lt;h4 id=&quot;strong-and-emphasize&quot;&gt;Strong and Emphasize&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;strong&lt;/strong&gt; or &lt;strong&gt;strong&lt;/strong&gt; ( Cmd + B )&lt;/p&gt;

&lt;p&gt;&lt;em&gt;emphasize&lt;/em&gt; or &lt;em&gt;emphasize&lt;/em&gt; ( Cmd + I )&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sometimes I want a lot of text to be bold.
Like, seriously, a &lt;em&gt;LOT&lt;/em&gt; of text&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;blockquotes&quot;&gt;Blockquotes&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Right angle brackets &amp;gt; are used for block quotes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;links-and-email&quot;&gt;Links and Email&lt;/h4&gt;

&lt;p&gt;An email &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#101;&amp;#120;&amp;#097;&amp;#109;&amp;#112;&amp;#108;&amp;#101;&amp;#064;&amp;#101;&amp;#120;&amp;#097;&amp;#109;&amp;#112;&amp;#108;&amp;#101;&amp;#046;&amp;#099;&amp;#111;&amp;#109;&quot;&gt;&amp;#101;&amp;#120;&amp;#097;&amp;#109;&amp;#112;&amp;#108;&amp;#101;&amp;#064;&amp;#101;&amp;#120;&amp;#097;&amp;#109;&amp;#112;&amp;#108;&amp;#101;&amp;#046;&amp;#099;&amp;#111;&amp;#109;&lt;/a&gt; link.&lt;/p&gt;

&lt;p&gt;Simple inline link &lt;a href=&quot;http://chenluois.com&quot;&gt;http://chenluois.com&lt;/a&gt;, another inline link &lt;a href=&quot;http://25.io/smaller/&quot;&gt;Smaller&lt;/a&gt;, one more inline link with title &lt;a href=&quot;http://resizesafari.com&quot; title=&quot;a Safari extension&quot;&gt;Resize&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;http://25.io/mou/&quot; title=&quot;Markdown editor on Mac OS X&quot;&gt;reference style&lt;/a&gt; link. Input id, then anywhere in the doc, define the link with corresponding id:&lt;/p&gt;

&lt;p&gt;Titles ( or called tool tips ) in the links are optional.&lt;/p&gt;

&lt;h4 id=&quot;images&quot;&gt;Images&lt;/h4&gt;

&lt;p&gt;An inline image &lt;img src=&quot;http://25.io/smaller/favicon.ico&quot; alt=&quot;Smaller icon&quot; title=&quot;Title here&quot; /&gt;, title is optional.&lt;/p&gt;

&lt;p&gt;A &lt;img src=&quot;http://resizesafari.com/favicon.ico&quot; alt=&quot;Resize icon&quot; title=&quot;Title&quot; /&gt; reference style image.&lt;/p&gt;

&lt;h4 id=&quot;inline-code-and-block-code&quot;&gt;Inline code and Block code&lt;/h4&gt;

&lt;p&gt;Inline code are surround by &lt;code&gt;backtick&lt;/code&gt; key. To create a block code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Indent each line by at least 1 tab, or 4 spaces.
var Mou = exactlyTheAppIwant; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;ordered-lists&quot;&gt;Ordered Lists&lt;/h4&gt;

&lt;p&gt;Ordered lists are created using “1.” + Space:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Ordered list item&lt;/li&gt;
  &lt;li&gt;Ordered list item&lt;/li&gt;
  &lt;li&gt;Ordered list item&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;unordered-lists&quot;&gt;Unordered Lists&lt;/h4&gt;

&lt;p&gt;Unordered list are created using “*” + Space:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Unordered list item&lt;/li&gt;
  &lt;li&gt;Unordered list item&lt;/li&gt;
  &lt;li&gt;Unordered list item&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Or using “-“ + Space:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Unordered list item&lt;/li&gt;
  &lt;li&gt;Unordered list item&lt;/li&gt;
  &lt;li&gt;Unordered list item&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;hard-linebreak&quot;&gt;Hard Linebreak&lt;/h4&gt;

&lt;p&gt;End a line with two or more spaces will create a hard linebreak, called &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; in HTML. ( Control + Return )&lt;br /&gt;
Above line ended with 2 spaces.&lt;/p&gt;

&lt;h4 id=&quot;horizontal-rules&quot;&gt;Horizontal Rules&lt;/h4&gt;

&lt;p&gt;Three or more asterisks or dashes:&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;headers&quot;&gt;Headers&lt;/h4&gt;

&lt;p&gt;Setext-style:&lt;/p&gt;

&lt;h1 id=&quot;this-is-h1&quot;&gt;This is H1&lt;/h1&gt;

&lt;h2 id=&quot;this-is-h2&quot;&gt;This is H2&lt;/h2&gt;

&lt;p&gt;atx-style:&lt;/p&gt;

&lt;h1 id=&quot;this-is-h1-1&quot;&gt;This is H1&lt;/h1&gt;
&lt;p&gt;## This is H2
### This is H3
#### This is H4
##### This is H5
###### This is H6&lt;/p&gt;

&lt;h3 id=&quot;extra-syntax&quot;&gt;Extra Syntax&lt;/h3&gt;

&lt;h4 id=&quot;footnotes&quot;&gt;Footnotes&lt;/h4&gt;

&lt;p&gt;Footnotes work mostly like reference-style links. A footnote is made of two things: a marker in the text that will become a superscript number; a footnote definition that will be placed in a list of footnotes at the end of the document. A footnote looks like this:&lt;/p&gt;

&lt;p&gt;That’s some text with a footnote.&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h4 id=&quot;strikethrough&quot;&gt;Strikethrough&lt;/h4&gt;

&lt;p&gt;Wrap with 2 tilde characters:&lt;/p&gt;

&lt;p&gt;~~Strikethrough~~&lt;/p&gt;

&lt;h4 id=&quot;fenced-code-blocks&quot;&gt;Fenced Code Blocks&lt;/h4&gt;

&lt;p&gt;Start with a line containing 3 or more backticks, and ends with the first line with the same number of backticks:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fenced code blocks are like Stardard Markdown’s regular code
blocks, except that they’re not indented and instead rely on
a start and end fence lines to delimit the code block.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;tables&quot;&gt;Tables&lt;/h4&gt;

&lt;p&gt;A simple table looks like this:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;First Header&lt;/th&gt;
      &lt;th&gt;Second Header&lt;/th&gt;
      &lt;th&gt;Third Header&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Content Cell&lt;/td&gt;
      &lt;td&gt;Content Cell&lt;/td&gt;
      &lt;td&gt;Content Cell&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Content Cell&lt;/td&gt;
      &lt;td&gt;Content Cell&lt;/td&gt;
      &lt;td&gt;Content Cell&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If you wish, you can add a leading and tailing pipe to each line of the table:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;First Header&lt;/th&gt;
      &lt;th&gt;Second Header&lt;/th&gt;
      &lt;th&gt;Third Header&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Content Cell&lt;/td&gt;
      &lt;td&gt;Content Cell&lt;/td&gt;
      &lt;td&gt;Content Cell&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Content Cell&lt;/td&gt;
      &lt;td&gt;Content Cell&lt;/td&gt;
      &lt;td&gt;Content Cell&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Specify alignment for each column by adding colons to separator lines:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;First Header&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Second Header&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Third Header&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Left&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Center&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;Right&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Left&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Center&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;Right&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;shortcuts&quot;&gt;Shortcuts&lt;/h3&gt;

&lt;h4 id=&quot;view&quot;&gt;View&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Toggle live preview: Shift + Cmd + I&lt;/li&gt;
  &lt;li&gt;Toggle Words Counter: Shift + Cmd + W&lt;/li&gt;
  &lt;li&gt;Toggle Transparent: Shift + Cmd + T&lt;/li&gt;
  &lt;li&gt;Toggle Floating: Shift + Cmd + F&lt;/li&gt;
  &lt;li&gt;Left/Right = 1/1: Cmd + 0&lt;/li&gt;
  &lt;li&gt;Left/Right = 3/1: Cmd + +&lt;/li&gt;
  &lt;li&gt;Left/Right = 1/3: Cmd + -&lt;/li&gt;
  &lt;li&gt;Toggle Writing orientation: Cmd + L&lt;/li&gt;
  &lt;li&gt;Toggle fullscreen: Control + Cmd + F&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;actions&quot;&gt;Actions&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Copy HTML: Option + Cmd + C&lt;/li&gt;
  &lt;li&gt;Strong: Select text, Cmd + B&lt;/li&gt;
  &lt;li&gt;Emphasize: Select text, Cmd + I&lt;/li&gt;
  &lt;li&gt;Inline Code: Select text, Cmd + K&lt;/li&gt;
  &lt;li&gt;Strikethrough: Select text, Cmd + U&lt;/li&gt;
  &lt;li&gt;Link: Select text, Control + Shift + L&lt;/li&gt;
  &lt;li&gt;Image: Select text, Control + Shift + I&lt;/li&gt;
  &lt;li&gt;Select Word: Control + Option + W&lt;/li&gt;
  &lt;li&gt;Select Line: Shift + Cmd + L&lt;/li&gt;
  &lt;li&gt;Select All: Cmd + A&lt;/li&gt;
  &lt;li&gt;Deselect All: Cmd + D&lt;/li&gt;
  &lt;li&gt;Convert to Uppercase: Select text, Control + U&lt;/li&gt;
  &lt;li&gt;Convert to Lowercase: Select text, Control + Shift + U&lt;/li&gt;
  &lt;li&gt;Convert to Titlecase: Select text, Control + Option + U&lt;/li&gt;
  &lt;li&gt;Convert to List: Select lines, Control + L&lt;/li&gt;
  &lt;li&gt;Convert to Blockquote: Select lines, Control + Q&lt;/li&gt;
  &lt;li&gt;Convert to H1: Cmd + 1&lt;/li&gt;
  &lt;li&gt;Convert to H2: Cmd + 2&lt;/li&gt;
  &lt;li&gt;Convert to H3: Cmd + 3&lt;/li&gt;
  &lt;li&gt;Convert to H4: Cmd + 4&lt;/li&gt;
  &lt;li&gt;Convert to H5: Cmd + 5&lt;/li&gt;
  &lt;li&gt;Convert to H6: Cmd + 6&lt;/li&gt;
  &lt;li&gt;Convert Spaces to Tabs: Control + [&lt;/li&gt;
  &lt;li&gt;Convert Tabs to Spaces: Control + ]&lt;/li&gt;
  &lt;li&gt;Insert Current Date: Control + Shift + 1&lt;/li&gt;
  &lt;li&gt;Insert Current Time: Control + Shift + 2&lt;/li&gt;
  &lt;li&gt;Insert entity &amp;lt;: Control + Shift + ,&lt;/li&gt;
  &lt;li&gt;Insert entity &amp;gt;: Control + Shift + .&lt;/li&gt;
  &lt;li&gt;Insert entity &amp;amp;: Control + Shift + 7&lt;/li&gt;
  &lt;li&gt;Insert entity Space: Control + Shift + Space&lt;/li&gt;
  &lt;li&gt;Insert Scriptogr.am Header: Control + Shift + G&lt;/li&gt;
  &lt;li&gt;Shift Line Left: Select lines, Cmd + [&lt;/li&gt;
  &lt;li&gt;Shift Line Right: Select lines, Cmd + ]&lt;/li&gt;
  &lt;li&gt;New Line: Cmd + Return&lt;/li&gt;
  &lt;li&gt;Comment: Cmd + /&lt;/li&gt;
  &lt;li&gt;Hard Linebreak: Control + Return&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;edit&quot;&gt;Edit&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Auto complete current word: Esc&lt;/li&gt;
  &lt;li&gt;Find: Cmd + F&lt;/li&gt;
  &lt;li&gt;Close find bar: Esc&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;post&quot;&gt;Post&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Post on Scriptogr.am: Control + Shift + S&lt;/li&gt;
  &lt;li&gt;Post on Tumblr: Control + Shift + T&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;export&quot;&gt;Export&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Export HTML: Option + Cmd + E&lt;/li&gt;
  &lt;li&gt;Export PDF:  Option + Cmd + P&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;and-more&quot;&gt;And more?&lt;/h3&gt;

&lt;p&gt;Don’t forget to check Preferences, lots of useful options are there.&lt;/p&gt;

&lt;p&gt;Follow &lt;a href=&quot;https://twitter.com/mou&quot;&gt;@Mou&lt;/a&gt; on Twitter for the latest news.&lt;/p&gt;

&lt;p&gt;For feedback, use the menu &lt;code&gt;Help&lt;/code&gt; - &lt;code&gt;Send Feedback&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;And that’s the footnote. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title></title>
   <link href="http://wangtengchuan.github.io/2016/03/09/new-post"/>
   <updated>2016-03-09T00:00:00+08:00</updated>
   <id>http://wangtengchuan.github.io/2016/03/09/new-post</id>
   <content type="html">
</content>
 </entry>
 
 <entry>
   <title>mysql笔记</title>
   <link href="http://wangtengchuan.github.io/2016/03/09/mysql"/>
   <updated>2016-03-09T00:00:00+08:00</updated>
   <id>http://wangtengchuan.github.io/2016/03/09/mysql</id>
   <content type="html">
</content>
 </entry>
 
 <entry>
   <title>2016年学习计划</title>
   <link href="http://wangtengchuan.github.io/2016/03/05/2016"/>
   <updated>2016-03-05T00:00:00+08:00</updated>
   <id>http://wangtengchuan.github.io/2016/03/05/2016</id>
   <content type="html">
&lt;p&gt;##2015年总结
马上就要工作满一年了，想起来时间过得可真快啊。不过过去一年生活上变化不大，房价倒是直接翻倍。想起来真是可怕。&lt;/p&gt;

&lt;p&gt;##2016年目标&lt;/p&gt;

&lt;p&gt;###2016年学习计划
1. 首先需要在3月份完成对redis的学习。因为公司docker环境默认部署有redis。所以用起来比较方便，最起码不用自己动手去部署了。
2. iOS学习。需要弄明白整个iOS开发的整套框架。争取能真正把集思路中套利的数据爬下来，然后做一个iOS的app。
3. epoll的学习。公司现有的后台框架，以及开源的Python框架Tornado都是基于epoll的。有必要去深入了解一下。（入股时间有富裕，还可以去学习一下flask）
4. Mooc上开源的计算机课程的学习。重点有几个: 
   1. iOS8编程（网易公开课）
   2. 编译原理（coursera）
   3. 算法导论&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Hello World</title>
   <link href="http://wangtengchuan.github.io/2016/02/28/hello-world"/>
   <updated>2016-02-28T00:00:00+08:00</updated>
   <id>http://wangtengchuan.github.io/2016/02/28/hello-world</id>
   <content type="html">
&lt;h2 id=&quot;hello-world&quot;&gt;Hello World&lt;/h2&gt;
&lt;p&gt;### This is my first blog using github.&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
